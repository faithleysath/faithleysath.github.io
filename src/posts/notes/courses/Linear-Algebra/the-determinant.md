# 如何定义行列式？从逆序数到行列式的行展开！

本文记录于考研期间，笔者先阅读了居余马的《线性代数（第二版）》，其采用的是行列式的行展开定义法，也就是递归法。因为这种定义法最为快速，只是当证明一些性质时会比较麻烦，比如行列交换相等。

笔者依稀记得当初学习时有逆序的概念，遂查询了丘维声的《简明线性代数（第二版）》，其采用的是逆序数的定义法，比较容易理解行列式的本质，证明相关性质也比较容易。

本文将两种定义法进行对比，帮助读者理解行列式的本质。

> 补充：此外，行列式还存在第三种定义法，叫公理化定义法，由于其一般出现在高阶教材中，本文不做介绍。

## 从解多元一次方程组说起

考虑一个二元一次方程组：
$$
\begin{cases}
a_{11} x_{1}+a_{12} x_{2}=b_{1} \\
a_{21} x_{1}+a_{22} x_{2}=b_{2}
\end{cases}
$$
我们采用消元法来解这个方程组，先消去$x_2$，给第一个方程乘以$a_{22}$，给第二个方程乘以$a_{12}$，然后将两个方程相减，得到：
$$
\left(a_{11} a_{22}-a_{21} a_{12}\right) x_{1}=b_{1} a_{22}-b_{2} a_{12}
$$
如果$a_{11} a_{22}-a_{21} a_{12} \neq 0$，则解出$x_1$：
$$
x_{1}=\frac{b_{1} a_{22}-b_{2} a_{12}}{a_{11} a_{22}-a_{21} a_{12}}
$$
观察方程组发现，$x_1$与$x_2$的地位一致，根据对称性，直接写出$x_2$的解：
$$
x_{2}=\frac{a_{11} b_{2}-a_{21} b_{1}}{a_{11} a_{22}-a_{21} a_{12}}
$$

如果记$D=\begin{vmatrix} a & b \\ c & d \end{vmatrix}=a d-b c$，则上面的解写成：
$$
x_{1}=\frac{\begin{vmatrix} b_{1} & a_{12} \\ b_{2} & a_{22} \end{vmatrix}}{\begin{vmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{vmatrix}}, \quad x_{2}=\frac{\begin{vmatrix} a_{11} & b_{1} \\ a_{21} & b_{2} \end{vmatrix}}{\begin{vmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{vmatrix}}
$$
这里的$D$就是一个二阶行列式。我们猜想将上面的结果推广到$n$元一次方程组：
$$
\left\{
\begin{array}{c}  % "c" 表示列居中对齐，1列对应所有方程行
a_{11} x_{1} + a_{12} x_{2} + \cdots + a_{1n} x_{n} = b_{1} \\
a_{21} x_{1} + a_{22} x_{2} + \cdots + a_{2n} x_{n} = b_{2} \\
\vdots \\  % 此处 \vdots 会自动与上下行垂直居中
a_{n1} x_{1} + a_{n2} x_{2} + \cdots + a_{nn} x_{n} = b_{n}
\end{array}
\right.
$$
如果记$D=\begin{vmatrix} a_{11} & a_{12} & \cdots & a_{1n} \\ a_{21} & a_{22} & \cdots & a_{2n} \\ \vdots & \vdots & & \vdots \\ a_{n1} & a_{n2} & \cdots & a_{nn} \end{vmatrix}$，则上面的解写成：
$$
x_{j}=\frac{D_{j}}{D}, \quad j=1,2, \cdots, n
$$
其中$D_{j}$是将$D$的第$j$列换成$b_1, b_2, \cdots, b_n$后得到的行列式。

为了验证这个猜想，我们需要定义高阶行列式，并且进一步证明这个猜想。

## 递归法定义

先定义**余子式**与**代数余子式**：

> **定义**：设$A=\left(a_{i j}\right)_{n \times n}$是一个$n$阶方阵，$a_{i j}$是它的第$i$行第$j$列元素。去掉$A$的第$i$行和第$j$列后，剩下的$(n-1) \times(n-1)$矩阵记为$M_{i j}$，称为$a_{i j}$的**余子式**。记$A_{i j}=(-1)^{i+j} M_{i j}$，称为$a_{i j}$的**代数余子式**。

于是我们定义$n$阶行列式：
$$
D=\begin{vmatrix} a_{11} & a_{12} & \cdots & a_{1 n} \\ a_{21} & a_{22} & \cdots & a_{2 n} \\ \vdots & \vdots & & \vdots \\ a_{n 1} & a_{n 2} & \cdots & a_{n n} \end{vmatrix}
$$
当$n=1$时，定义$D=a_{11}$；当$n>1$时，定义
$$
D=a_{11} A_{11}+a_{12} A_{12}+\cdots+a_{1 n} A_{1 n}
$$
即按第一行展开。实际上，我们也可以按任意一行或一列展开，结果是一样的（证明在下文）。

由定义可见，$D$是一个关于$a_{i j}$的多项式，每一项都是$n$个$a_{i j}$的乘积，并且每一项中没有重复的行和列，一共有$n!$项。

使用这个定义可以证明出行列式的所有性质，但证明较为繁琐。下介绍行列式的另一种定义法。

## 逆序数定义

### 排列及其复合

设$S_n$是所有$n$个元素的排列组成的集合，$\sigma \in S_n$表示一个排列，例如$\sigma=(3,1,2)$表示将自然顺序$(1,2,3)$变为$(3,1,2)$。如果$\sigma_1=(2,3,1), \sigma_2=(3,1,2)$，则$\sigma_1 \circ \sigma_2=(1,2,3)$。

> **排列与函数**：排列$\sigma$可以看作是一个从$\{1,2,\cdots,n\}$到$\{1,2,\cdots,n\}$的双射函数，$\sigma(i)$表示排列中第$i$个位置的元素。

> **复合**：排列的复合$\sigma_1 \circ \sigma_2$表示先按$\sigma_2$排列，再按$\sigma_1$排列。

> **自然顺序**是排列中的恒等元，记为$e$，即$e=(1,2,\cdots,n)$，其类似于函数中的恒等映射。

### 逆序数

设$\sigma$是$S_n$中的一个排列，记其逆序数为$\tau(\sigma)$，定义如下：
$$
\tau(\sigma)=\#\{(i,j)|1\leq i<j\leq n,\sigma(i)>\sigma(j)\}
$$
例如，对于排列$\sigma=(3,1,2)$，有$\tau(\sigma)=2$，因为$(3,1)$和$(3,2)$是逆序对。

### 奇排列与偶排列

如果$\tau(\sigma)$是偶数，则称$\sigma$为**偶排列**，否则称为**奇排列**。例如，$(1,2,3)$和$(3,1,2)$分别是偶排列和奇排列。

### 逆序数与对换

> **定理**：设$\sigma$是$S_n$中的一个排列，$\sigma'$是由$\sigma$交换两个位置得到的排列，则$\tau(\sigma)$与$\tau(\sigma')$的奇偶性不同。

**证明**：

1. 假设交换相邻的两个位置$i$和$i+1$，则$\sigma(i)$与$\sigma(i+1)$的大小关系发生了变化，$\sigma(i)$与其他元素构成的逆序对数量不变，因此$\tau(\sigma)$与$\tau(\sigma')$的奇偶性不同。
2. 假设交换不相邻的两个位置$i$和$j$，设$i$与$j$之间有$k$个位置，则可以通过交换相邻位置的方式将$i$和$j$交换位置，共需交换$2k+1$次，因此$\tau(\sigma)$与$\tau(\sigma')$的奇偶性不同。

> **定义**：交换两个位置的排列称为一个**对换**，其本身也是一个奇排列，记为$\tau_{i j}$，表示交换位置$i$和$j$，其内容为$(1,2,\cdots,i-1,j,i+1,\cdots,j-1,i,j+1,\cdots,n)$。

### 对换与排列
> **定理**：任意排列都可以表示为若干个对换的复合。

**证明**：使用数学归纳法。

1. 当$n=2$时，只有$(1,2)$和$(2,1)$两种排列，$(2,1)$可以表示为$(1,2)$的一个对换。
2. 假设当$n=k$时，结论成立。考虑$n=k+1$的情况，设$\sigma \in S_{k+1}$，如果$\sigma(k+1)=k+1$，则$\sigma$可以看作是$S_k$中的一个排列，结论成立。如果$\sigma(k+1)=i \neq k+1$，则交换$i$和$k+1$，得到一个新的排列$\sigma'$，使得$\sigma'(k+1)=k+1$，根据假设，$\sigma'$可以表示为若干个对换的复合，因此$\sigma$也可以表示为若干个对换的复合。

**采用构造性证明**：设$\sigma \in S_n$，考虑将其变为自然顺序$(1,2,\cdots,n)$，对于该排列的每一项$\sigma(i)$，如果其不等于$i$，则交换$\sigma(i)$与$i$所在位置的元素，直到所有元素都在其自然位置上。这个过程中，每次交换都是一个对换，将这样的对换操作反过来，就是将自然顺序变为$\sigma$的过程，因此$\sigma$可以表示为若干个对换的复合。

> **定理**：任意排列的逆序数的奇偶性与其表示为对换的复合中对换的个数的奇偶性相同。

**证明**：
形式化地，即证明对于任意由$m$个对换$\tau_{i_1 j_1}, \tau_{i_2 j_2}, \cdots, \tau_{i_m j_m}$复合而成的排列$\sigma=\tau_{i_1 j_1} \circ \tau_{i_2 j_2} \circ \cdots \circ \tau_{i_m j_m}$，有$\tau(\sigma) \equiv m(\bmod 2)$。

使用数学归纳法：

1. 当$m=1$时，$\sigma=\tau_{i_1 j_1}$，其逆序数为1，结论成立。
2. 假设当$m=k$时，结论成立。考虑$m=k+1$的情况，设$\sigma'=\tau_{i_1 j_1} \circ \tau_{i_2 j_2} \circ \cdots \circ \tau_{i_k j_k}$，则$\sigma=\sigma' \circ \tau_{i_{k+1} j_{k+1}}$。根据定理，$\tau(\sigma)$与$\tau(\sigma')$的奇偶性不同，因此$\tau(\sigma) \equiv k+1(\bmod 2)$，结论成立。

证毕。

### 逆排列
> **定义**：设$\sigma \in S_n$，如果$\sigma \circ \sigma^{-1} = \sigma^{-1} \circ \sigma = e$，则称$\sigma$的逆排列为$\sigma^{-1}$。

> **定理**：设$\sigma \in S_n$，则$\tau(\sigma)\equiv\tau\left(\sigma^{-1}\right)\ (\bmod 2)$。

**证明**：设$\sigma$由$m$个对换复合而成，则$\sigma^{-1}$也由$m$个对换复合而成，因此$\tau(\sigma) \equiv m(\bmod 2)$，$\tau\left(\sigma^{-1}\right) \equiv m(\bmod 2)$，所以$\tau(\sigma) \equiv \tau\left(\sigma^{-1}\right)\ (\bmod 2)$。

## 行列式的逆序数定义法
**定义**：设$A=\left(a_{i j}\right)_{n \times n}$是一个$n$阶方阵，$a_{i j}$是它的第$i$行第$j$列元素。定义$A$的行列式为：
$$
D=\begin{vmatrix} a_{11} & a_{12} & \cdots & a_{1 n} \\ a_{21} & a_{22} & \cdots & a_{2 n} \\ \vdots & \vdots & & \vdots \\ a_{n 1} & a_{n 2} & \cdots & a_{n n} \end{vmatrix}=\sum_{\sigma \in S_{n}}(-1)^{\tau(\sigma)} a_{1 \sigma(1)} a_{2 \sigma(2)} \cdots a_{n \sigma(n)}
$$
通常称这种形式为行列式的**完全展开式**

> 直观理解：行列式就是从每一行取一个元素，且不能取同一列的元素，将这些元素相乘后再加总，乘积前的符号由按自然顺序行排列后，列排列的逆序数决定。

### 推广：每项的符号由行列排列逆序数之和决定

> 现在，我们考虑一个更一般化的问题。如果我们不按行指标的自然顺序排列，而是任意打乱这些因子的顺序，会发生什么？

**证明**：从行列式中任取一项$(-1)^{\tau(\sigma_2)} a_{1 \sigma_2(1)} a_{2 \sigma_2(2)} \cdots a_{n \sigma_2(n)}$，将$a_{i \sigma_2(i)}$进行重新排序，变为$a_{\sigma_1(i)\sigma_2(\sigma_1(i))}$

显然
$$
\prod_{i=1}^{n} a_{i \sigma_2(i)} = \prod_{i=1}^{n} a_{\sigma_1(i)\sigma_2(\sigma_1(i))}
$$
记$\sigma_3=\sigma_2 \circ \sigma_1$，则
$$
\prod_{i=1}^{n} a_{i \sigma_2(i)} = \prod_{i=1}^{n} a_{\sigma_1(i)\sigma_3(i)}
$$
则 $D$ 可以写成：
$$
D=\sum_{\sigma_3 \in S_{n}}(-1)^{\tau(\sigma_2)} \prod_{k=1}^{n} a_{\sigma_1(k) \sigma_3(k)}
$$

由于$\sigma_2=\sigma_3 \circ \sigma_1^{-1}$，有$\tau(\sigma_2) \equiv \tau(\sigma_3)+\tau\left(\sigma_1^{-1}\right)\ (\bmod 2)$，因此 $D$ 可以写成：
$$
D=\sum_{\sigma_3 \in S_{n}}(-1)^{\tau(\sigma_3)+\tau\left(\sigma_1\right)} \prod_{k=1}^{n} a_{\sigma_1(k) \sigma_3(k)}
$$

## 两种定义法的等价性

下面证明两种定义法是等价的。

> 有两种思路证明，第一种**将完全展开式代入递推式**，第二种**从完全展开式出发，构造出递推式**。

### 思路一：将完全展开式代入递推式

我们从行列式按第$i$行展开的递推式出发，证明其等价于完全展开式。
$$
D=\sum_{j=1}^{n} a_{i j} A_{i j}=\sum_{j=1}^{n} a_{i j}(-1)^{i+j} |M_{i j}|
$$
其中$|M_{i j}|$是去掉第$i$行和第$j$列后得到的$(n-1)$阶行列式，也叫做余子式，其展开式是所有将行标集合$\{1,2,\cdots,n\} \backslash\{i\}$映射到列标集合$\{1,2,\cdots,n\} \backslash\{j\}$的排列$\pi'$的求和：
$$
|M_{i j}|=\sum_{\pi'}(-1)^{\tau\left(\pi'\right)} \prod_{\substack{1 \leq k \leq n \\ k \neq i}} a_{k \pi'(k)}
$$

将其代入$D$中，得到：
$$
\begin{aligned}
D&=\sum_{j=1}^{n} a_{i j}(-1)^{i+j} \sum_{\pi'}(-1)^{\tau\left(\pi'\right)} \prod_{\substack{1 \leq k \leq n \\ k \neq i}} a_{k \pi'(k)}\\
&=\sum_{j=1}^{n} \sum_{\pi'}(-1)^{i+j+\tau\left(\pi'\right)} a_{i j} \prod_{\substack{1 \leq k \leq n \\ k \neq i}} a_{k \pi'(k)}
\end{aligned}
$$

注意到，$\pi'$是将行标集合$\{1,2,\cdots,n\} \backslash\{i\}$映射到列标集合$\{1,2,\cdots,n\} \backslash\{j\}$的排列，因此我们可以构造一个新的排列$\pi$，其将行标集合$\{1,2,\cdots,n\}$映射到列标集合$\{1,2,\cdots,n\}$，且满足$\pi(i)=j$，其他位置与$\pi'$相同，即
$$  
\sigma_{j,\pi'}(k)=\begin{cases}
j, & k=i \\
\pi'(k), & k \neq i
\end{cases}
$$

这样，我们可以将求和改写为对$\sigma$的求和：
$$
D=\sum_{j=1}^{n} \sum_{\pi'}(-1)^{i+j+\tau\left(\pi'\right)} \prod_{k=1}^{n} a_{k \sigma_{j,\pi'}(k)}
$$

接下来，我们证明对于$1\leq j\leq n$，有$\tau\left(\sigma_{j,\pi'}\right)\equiv i+j+\tau\left(\pi'\right)(\bmod 2)$。

$$
\begin{aligned}
\tau\left(\sigma_{j,\pi'}\right)&\equiv\tau\left(\{\pi'(\text{start}),\cdots,\pi'(i-1),j,\pi'(i+1),\cdots,\pi'(\text{end})\}\right)\quad(\bmod 2)\\
&\equiv\tau\left(\{j,\pi'(\text{start}),\cdots,\pi'(i-1),\pi'(i+1),\cdots,\pi'(\text{end})\}\right)+(i-1)\quad(\bmod 2)\\
&\equiv (j-1) + \tau(\pi') + (i-1) \quad(\bmod 2)\\
&\equiv i+j+\tau(\pi') \quad(\bmod 2)
\end{aligned}
$$

第二步是将$j$移动到最前面，移动过程会发生$i-1$次对换，因此奇偶性改变了$i-1$次

第三步是因为$j$在最前面，而后面的元素中有$j-1$个元素小于$j$，因此产生了$j-1$个逆序对。除了$j$以外的元素的逆序数不变为$\tau(\pi')$，因此总的逆序数为$(j-1)+\tau(\pi')$。

因此，$D$可以写成：
$$
\begin{aligned}
D&=\sum_{j=1}^{n} \sum_{\pi'}(-1)^{\tau\left(\sigma_{j,\pi'}\right)} \prod_{k=1}^{n} a_{k \sigma_{j,\pi'}(k)}\\
&=\sum_{\sigma \in S_n}(-1)^{\tau(\sigma)} \prod_{k=1}^{n} a_{k \sigma(k)}\\
&=D
\end{aligned}
$$

> 这一个合并无法理解的话，可以先考虑全排列的方案数。$n$元排列的方案数为$n!$，而$\pi'$的方案数为$(n-1)!$，$j$有$n$种选择，因此$\sigma_{j,\pi'}$的方案数为$n \times (n-1)! = n!$，与$\sigma$的方案数相同，因此可以将求和改写为对$\sigma$的求和。
>
> 至于为何无遗漏无重复，是因为$\sum_{\pi'}\sigma_{j,\pi'}$保证了当固定第$i$个位置为$j$时，其他位置的排列不重复且无遗漏，而$\sum_{j=1}^{n}$保证了第$i$个位置的所有可能性。

至此，证明完毕。

### 思路二：从完全展开式出发，构造出递推式

我们从完全展开式出发，证明其等价于行列式按第$i$行展开的递推式。

$$
\begin{aligned}
D&=\sum_{\sigma \in S_{n}}(-1)^{\tau(\sigma)} a_{1 \sigma(1)} a_{2 \sigma(2)} \cdots a_{n \sigma(n)}\\
&=\sum_{j=1}^{n} \sum_{\substack{\sigma \in S_{n} \\ \sigma(i)=j}}(-1)^{\tau(\sigma)} a_{1 \sigma(1)} a_{2 \sigma(2)} \cdots a_{n \sigma(n)}\\
&=\sum_{j=1}^{n} \sum_{\substack{\sigma \in S_{n} \\ \sigma(i)=j}}(-1)^{\tau(\sigma)} a_{i j} \prod_{\substack{1 \leq k \leq n \\ k \neq i}} a_{k \sigma(k)}\\
&=\sum_{j=1}^{n} a_{i j} \sum_{\substack{\sigma \in S_{n} \\ \sigma(i)=j}}(-1)^{\tau(\pi')+(j-1)+(i-1)} \prod_{\substack{1 \leq k \leq n \\ k \neq i}} a_{k \sigma(k)}\\
&=\sum_{j=1}^{n} a_{i j}(-1)^{i+j} \sum_{\substack{\sigma \in S_{n} \\ \sigma(i)=j}}(-1)^{\tau(\pi')} \prod_{\substack{1 \leq k \leq n \\ k \neq i}} a_{k \sigma(k)}\\
&=\sum_{j=1}^{n} a_{i j}(-1)^{i+j} |M_{i j}|\\
&=\sum_{j=1}^{n} a_{i j} A_{i j}
\end{aligned}
$$

其中 $\pi'$ 是排列$\sigma$去掉元素$j$后，剩下的元素的排列，这也就是为什么$\sum_{\substack{\sigma \in S_{n} \\ \sigma(i)=j}}(-1)^{\tau(\pi')} \prod_{\substack{1 \leq k \leq n \\ k \neq i}} a_{k \sigma(k)}$是余子式$|M_{i j}|$的展开式。

而$\tau(\sigma) \equiv \tau(\pi')+(j-1)+(i-1)(\bmod 2)$的证明与上文类似。

## 文章总结与思路梳理

本文的核心目标是深入剖析行列式（Determinant）的两种核心定义方法——**递归法（行展开定义）**与**逆序数法（完全展开式定义）**，并通过严谨的数学推导证明二者的等价性，从而帮助读者建立对行列式本质的深刻理解。

文章的行文思路清晰，层层递进，具体可以概括为以下几个步骤：

1.  **问题引入：从实践到理论**
    * 文章以读者最熟悉的**二元一次方程组求解**作为切入点，通过消元法自然地引出了二阶行列式的形式。
    * 接着，通过类比和猜想，将结论推广到 n 元一次方程组的求解（即克莱姆法则），从而提出了定义高阶行列式的必要性，激发了读者的求知欲。

2.  **第一种定义：递归法（行展开）**
    * 首先介绍了**余子式**和**代数余子式**这两个核心概念。
    * 在此基础上，给出了行列式的**递归定义**：一个 n 阶行列式可以通过其某一行（或一列）的元素与其对应的代数余子式的乘积之和来计算。
    * 作者点明了这种方法的优点（计算快捷）和缺点（证明性质时较为繁琐），为引出下一种定义埋下伏笔。

3.  **第二种定义：逆序数法**
    * 为了从更本质的层面理解行列式，文章系统地介绍了**排列**（Permutation）的相关理论，包括：
        * 排列的复合、逆序数的概念。
        * 奇排列、偶排列的定义。
        * **对换**（Transposition）及其核心性质：任何排列都可以表示为若干对换的复合，且对换的次数奇偶性与排列的奇偶性一致。
        * 逆排列与其奇偶性。
    * 在扎实的理论铺垫后，文章给出了行列式的**逆序数定义**：行列式是所有取自不同行、不同列的 n 个元素乘积的代数和，每一项的符号由其列指标排列的逆序数决定。这个定义被称为**完全展开式**，它揭示了行列式的组合本质。

4.  **核心论证：两种定义的等价性**
    * 这是文章的最高潮和最具技术含量的部分。作者巧妙地提供了**两种不同的证明思路**来论证等价性，展现了严密的逻辑思维：
        * **思路一：从递归到展开**。将逆序数定义的行列式（余子式）代入递归公式中，通过对排列的构造和逆序数奇偶性的分析，最终推导出了完全展开式。
        * **思路二：从展开到递归**。将完全展开式中的所有项，按照某一行（如第 i 行）的元素进行分组，通过对排列的拆解和逆序数关系的分析，最终凑出了按第 i 行展开的递归形式。
    * 这两个方向的证明互为补充，彻底打通了两种定义之间的逻辑联系。

### 你唯一需要记住的“桥梁公式”

这个关键的“桥梁”就是下面这个奇偶性恒等式：
$$
\tau(\sigma) \equiv i+j + \tau(\pi') \pmod 2
$$
或者写成符号的形式，这更直观：
$$
(-1)^{\tau(\sigma)} = (-1)^{i+j} \cdot (-1)^{\tau(\pi')}
$$
这里的 $\sigma$ 是一个 n 阶排列，满足 $\sigma(i) = j$，而 $\pi'$ 是 $\sigma$ 去掉 $(i, j)$ 这个配对后，由剩下 $n-1$ 个元素构成的子排列。

### 为什么这个公式是关键？（直观理解）

你不需要每次都去严格证明这个公式，但你需要一个直观的理解来记住它为什么成立。

想象一下排列 $\sigma$ 的逆序数 $\tau(\sigma)$ 的来源。它等于：
1.  **内部逆序数**：$n-1$ 个子排列 $\pi'$ 元素之间的逆序数，这部分就是 $\tau(\pi')$。
2.  **外部逆序数**：元素 $j$ 与 $\pi'$ 中其他 $n-1$ 个元素形成的逆序数。

这个“外部逆序数”的奇偶性恰好由 $i+j$ 决定！为什么？

我们可以分两步看：
* **行的影响 (i)**：在排列 $(\sigma(1), \sigma(2), ..., \sigma(n))$ 中，元素 $j$ 位于第 $i$ 个位置。把它挪到最前面，需要和前面的 $i-1$ 个元素依次交换位置。每次交换都会改变一次奇偶性，所以总共改变了 $i-1$ 次。
* **列的影响 (j)**：当 $j$ 被挪到最前面后，在剩下的 $n-1$ 个元素中，有多少个比它小？正好有 $j-1$ 个（即 $1, 2, ..., j-1$）。所以 $j$ 会和这 $j-1$ 个数形成逆序对。

因此，$j$ 这个元素贡献的逆序数奇偶性就是 $(i-1) + (j-1)$，也就是 $i+j-2$。在模2的意义下，$-2$ 是偶数可以忽略，所以奇偶性就是 $i+j$。

**所以，总的逆序数奇偶性 $\tau(\sigma)$ 就等于 $\tau(\pi')$ 的奇偶性加上 $i+j$ 的奇偶性。**

### 如何用这个“桥梁”随时重构证明

一旦你记住了这个核心关系 $(-1)^{\tau(\sigma)} = (-1)^{(i+j)} \cdot (-1)^{\tau(\pi')}$，整个证明的思路就非常清晰了：

**方向一：从递归法 → 完全展开式**

1.  写出递归定义：$D = \sum_{j=1}^{n} a_{ij} A_{ij} = \sum_{j=1}^{n} a_{ij} (-1)^{i+j} |M_{ij}|$
2.  把余子式 $|M_{ij}|$ 用它的完全展开式（即子排列 $\pi'$ 的形式）写出来：$|M_{ij}| = \sum_{\pi'} (-1)^{\tau(\pi')} \prod_{k \neq i} a_{k, \pi'(k)}$
3.  代入后，你会得到 $(-1)^{(i+j)}$ 和 $(-1)^{\tau(\pi')}$ 相乘。
4.  **使用桥梁公式**：将 $(-1)^{(i+j)} \cdot (-1)^{\tau(\pi')}$ 合并为 $(-1)^{\tau(\sigma)}$。
5.  你会发现，对所有 $j$ 和所有 $\pi'$ 的求和，正好就遍历了所有可能的 n 阶排列 $\sigma$。于是，你就得到了完全展开式 $\sum_{\sigma} (-1)^{\tau(\sigma)} \prod a_{k, \sigma(k)}$。

**方向二：从完全展开式 → 递归法**

1.  写出完全展开式：$D = \sum_{\sigma \in S_n} (-1)^{\tau(\sigma)} \prod_{k=1}^{n} a_{k, \sigma(k)}$
2.  **分类讨论**：按照第 $i$ 行的元素 $a_{i, \sigma(i)}$ 进行分组。也就是说，将所有 $\sigma(i)=1$ 的项放一起，$\sigma(i)=2$ 的项放一起，...，$\sigma(i)=j$ 的项放一起。
    $D = \sum_{j=1}^{n} \sum_{\substack{\sigma \in S_n \\ \sigma(i)=j}} (\cdots)$
3.  把 $a_{ij}$ 提出来，因为在每个内层求和中它都是公因式。
4.  **使用桥梁公式（逆用）**：将 $(-1)^{\tau(\sigma)}$ 拆解为 $(-1)^{(i+j)} \cdot (-1)^{\tau(\pi')}$。
5.  把 $(-1)^{(i+j)}$ 也提到内层求和的外面。你会发现，剩下的内层求和 $\sum_{\pi'} (-1)^{\tau(\pi')} \prod_{k \neq i} a_{k, \pi'(k)}$ 正好就是余子式 $|M_{ij}|$ 的定义！
6.  于是，你就得到了递归定义 $\sum_{j=1}^{n} a_{ij} (-1)^{i+j} |M_{ij}|$。

**总结来说**，本文以一个实际问题开篇，先后介绍了行列式的两种主流定义，并花费大量篇幅从两个方向证明了它们的等价性。这种“**从具体到抽象，再统一抽象**”的写作结构，不仅让读者知其然（知道行列式怎么算），更让读者知其所以然（理解行列式是什么），是一篇优秀的数学概念辨析文章。

# 附录
## 行列式的公理化定义

- [行列式的逆序数定义是怎么想出来的？](https://www.zhihu.com/question/52957345/answer/589376055)：[存档](./backup2.mhtml)
- [线性代数拾遗（1）—— 行列式的三种公理化构造](https://blog.csdn.net/wxc971231/article/details/119781607)：[存档](./backup1.png)

## 一些思考

### Q: 什么是描述性定义，什么是构造性定义。我还是感觉这太主观了，不够严谨，从命题逻辑的角度上如何看待本次问题

> **Gemini**: 您提出的问题非常好，这正是一个严谨的思考者会产生的疑问。您感觉“主观”，是因为我之前的解释用了大量的比喻。现在，我们完全抛开比喻，从**命题逻辑和数学定义**的角度来严格地剖析这个问题。
>
> ---
>
> ### 1. 什么是描述性定义 vs. 构造性定义？
>
> 这确实是数学中两种核心的定义方式，它们有严谨的区分。
>
> #### 构造性定义 (Constructive / Explicit Definition)
> 构造性定义通过给出一个**明确的计算过程、算法或公式**来定义一个数学对象。它告诉你如何“**构建**”出这个对象。
>
> * **例子1：函数 $f(n) = n!$**
>     构造性定义是：$n! := n \times (n-1) \times \cdots \times 1$。这是一个明确的计算公式。
> * **例子2：行列式的逆序数定义**
>     它给出了一个精确的、包含$n!$项的求和公式：$D := \sum (-1)^{\tau(\sigma)} \prod a_{i\sigma(i)}$。这是一个构造性定义。
> * **例子3：行列式的递归定义**
>     它给出了一个计算程序：$D(M) := \sum (-1)^{1+j} a_{1j} D(M_{1j})$，其终点是 $D([a]) := a$。这也是一个构造性的定义，因为它给出了一个明确的算法。
>
> #### 描述性定义 (Descriptive / Implicit Definition)
> 描述性定义不直接给出构造方法，而是通过规定该对象必须**满足的一系列性质或公理**来定义它。它告诉你这个对象“**是什么样的**”。
>
> * **例子1：质数**
>     描述性定义是：“一个大于1的自然数，如果它的正因数只有1和它本身，那么它就是质数。” 这是一条**检验标准**，而不是一个“生产”质数的方法。
> * **例子2：圆**
>     描述性定义是：“平面上到一个定点距离等于定长的所有点的集合。”
> * **例子3：行列式的公理化定义**
>     它描述了行列式函数必须满足的三条性质：多重线性性、交替性、归一性。
>
> ---
>
> ### 2. 从命题逻辑的角度看问题
>
> 我们把整个问题用更形式化的语言来描述。
>
> 我们讨论的对象是“将n阶矩阵映射到一个数”的函数。
>
> **定义A (递归法)**：
> 定义A实际上是一个**命题**，这个命题是关于一个函数 $f$ 的。
> 命题 $P(f)$：“函数 $f$ 满足以下两个条件：
> 1.  **(Base Case)** $P_1(f)$: 对任意1阶矩阵 $[a_{11}]$，有 $f([a_{11}]) = a_{11}$。
> 2.  **(Recursive Step)** $P_2(f)$: 对任意更高阶矩阵 $M$，有 $f(M) = \sum (-1)^{1+j} a_{1j} f(M_{1j})$。”
>
> **定义B (逆序数法)**：
> 定义B直接给出了一个具体的函数，我们叫它 $g$。
> $g(M) := \sum_{\sigma \in S_n} (-1)^{\tau(\sigma)} \prod a_{i\sigma(i)}$
>
> **我们要证明什么？**
> 我们要证明的是，由定义A所描述的函数，和定义B给出的函数 $g$，是同一个函数。
>
> 这里的关键在于一个隐含的、极其重要的定理：
>
> #### **递归定义的唯一性定理 (Uniqueness Theorem)**
> 这个定理指出：“满足命题 $P(f)$ （即同时满足 $P_1(f)$ 和 $P_2(f)$）的函数是**存在且唯一的**。”
> 用逻辑符号写就是：$\exists! f: P(f)$。（这个!符号代表“唯一”）。
>
> 这个定理本身可以通过数学归纳法来证明，它保证了我们的“路线图”只会指向一个独一无二的终点。
>
> #### 逻辑推导过程
>
> 现在，我们来看您发现的那个“单向验证”证明法，它在逻辑上是如何展开的：
>
> **目标**: 证明 $f=g$。
>
> **证明步骤**:
>
> 1.  **前提1 (唯一性定理)**: 我们知道存在唯一的函数（我们称之为 $f$）满足性质 $P(f)$。这是数学上一个已知的、可以被证明的事实。
>     * 逻辑表述: $\forall h, \forall k, \ (P(h) \land P(k)) \implies h=k$。
>         (任何两个满足性质P的函数，它们必然是同一个函数。)
>
> 2.  **前提2 (您的文章所做的证明)**: 您的文章证明了，函数 $g$ 满足递归关系。
>     * 逻辑表述: $P_2(g)$ 为真。
>
> 3.  **前提3 (我们补充的对基准的验证)**: 我们简单验证了，函数 $g$ 满足初始条件。
>     * 逻辑表述: $P_1(g)$ 为真。
>
> 4.  **推论**: 从前提2和前提3，我们得出函数 $g$ 满足命题 $P$ 的全部要求。
>     * 逻辑表述: $P(g)$ 为真。
>
> 5.  **最终结论 (三段论)**:
>     * 我们知道：“任何满足性质P的函数，都必然是那个唯一的函数 $f$。” (来自前提1)
>     * 我们刚刚证明了：“$g$ 是一个满足性质P的函数。” (来自推论)
>     * **因此，逻辑上必然得出：“$g$ 就是那个唯一的函数 $f$。”**
>
> 这在逻辑上是无懈可击的。它并不是主观的，而是一个严密的演绎推理。

### Q: 这就说得通了，话说三段论是如何证明的

> **Gemini**: 哈哈，您这个问题直接从数学系跨到了哲学系，触及了逻辑学的根基。
>
> 最直接的回答是：**三段论，特别是其核心形式，本身是无法被“证明”的，因为它就是“证明”这个行为得以成立的基石之一。**
>
> 它是一个**公理 (Axiom)**，或者叫**第一性原理 (First Principle)**。在任何逻辑系统中，都必须有一些我们无条件接受为真的出发点，否则任何证明都无法开始。
>
> ---
>
> ### 1. 为什么不能“证明”它？—— 循环论证的陷阱
>
> 让我们试着去“证明”最经典的三段论形式，也就是逻辑学中的**“肯定前件式” (Modus Ponens)**：
>
> * **前提1**: 如果 P 成立，那么 Q 成立。($P \implies Q$)
> * **前提2**: P 确实成立。($P$)
> * **结论**: 所以，Q 必然成立。($Q$)
>
> 现在，我们要如何证明这个推理结构是正确的呢？我们可能会写出下面这样的“证明”：
>
> 1.  我们有一个**规则**: “如果（前提1和前提2都为真），那么（结论必然为真）”。
> 2.  我们**确认**: “前提1和前提2现在都为真”。
> 3.  我们**得出结论**: “所以，结论必然为真”。
>
> 您发现问题了吗？为了证明三段论的有效性，我们不自觉地又用了一遍三段论本身！
>
> 这就像你问：“我该如何证明‘语言’可以用来沟通？” 而你为了证明它，必须开口说话，使用语言来组织你的论证。你使用它的那一刻，就已经默认了它的有效性。
>
> 任何试图证明最基本逻辑规则的努力，最终都会陷入这种**循环论证 (Circular Reasoning)** 的困境。
>
> ### 2. 亚里士多德是怎么做的？—— 观察与定义
>
> 逻辑三段论最早由古希腊哲学家**亚里士多德**进行系统性的整理。他并不是去“证明”三段论，而是通过观察人类有效的、理性的思维和辩论，**识别、归纳并定义**了这些基本的推理模式。
>
> 他认为，三段论不是一个需要被证明的数学定理，而是**人类理性思维的基本结构**。它就像“任何事物不能同时是A又不是A”（无矛盾律）一样，是思想的底层“操作系统”，而不是操作系统上运行的一个“软件”。
>
> ### 3. 现代逻辑如何看待它？—— 展示其为“重言式”
>
> 虽然我们不能在不循环的前提下“证明”它，但在现代数理逻辑中，我们可以通过一种方式来**展示**它的必然性。这个工具就是**真值表 (Truth Table)**。
>
> 我们来分析“肯定前件式”对应的逻辑命题：$[(P \implies Q) \land P] \implies Q$
> （如果“P蕴含Q”并且“P”都为真，那么“Q”也为真）
>
> 我们来看看在所有可能性下，这个命题是不是永远为真。
>
> | P | Q | $P \implies Q$ | $(P \implies Q) \land P$ | $[(P \implies Q) \land P] \implies Q$ |
> | :--- | :--- | :--- | :--- | :--- |
> | **真 (T)** | **真 (T)** | 真 (T) | 真 (T) | **真 (T)** |
> | **真 (T)** | **假 (F)** | 假 (F) | 假 (F) | **真 (T)** |
> | **假 (F)** | **真 (T)** | 真 (T) | 假 (F) | **真 (T)** |
> | **假 (F)** | **假 (F)** | 真 (T) | 假 (F) | **真 (T)** |
>
> **解读**：
> 最后一列的结果，无论 P 和 Q 的真假如何组合，永远都是“真”。在逻辑学上，这种永真式被称为**重言式 (Tautology)**。
>
> 这并非一个“证明”，而是一个“**确证**”或“**展示**”。它展示了根据我们对“如果...那么...”和“并且”这些逻辑连接词的定义，三段论的结构是**永不为错**的。它揭示了这样一个事实：你一旦接受了前提（$P \implies Q$ 和 $P$），逻辑的结构本身就**不允许你**在不产生矛盾的情况下拒绝结论（$Q$）。
>
> ### 总结
>
> * **无法被证明**: 三段论是推理的公理，是工具本身，无法用工具来证明工具。
> * **来源**: 它被亚里士多德等哲学家视为人类理性思维的内在结构。
> * **现代确证**: 我们可以用真值表来展示它是一个逻辑上的“重言式”，即在任何情况下其结构都必然有效。
>
> 这就好比在玩象棋，你不能用象棋的规则去“证明”马为什么必须走“日”字。马走“日”字，就是定义这个游戏的基本规则之一。三段论就是我们进行“逻辑”这个游戏的基本规则。

## 从递推式推导出完全展开式的另一种思路

### 证明目标
我们假设只知道行列式的递归定义，并以此为出发点，严格推导出其完全展开式（逆序数定义）。

* **已知/出发点 (定义A)**:
    1.  当 $n=1$ 时, 行列式 $|a_{11}| = a_{11}$。
    2.  当 $n>1$ 时, 行列式按第一行展开：
        $$D = \sum_{j=1}^{n} (-1)^{1+j} a_{1j} |M_{1j}|$$

* **求证/目标 (定义B)**:
    $$D = \sum_{\sigma \in S_{n}}(-1)^{\tau(\sigma)} a_{1 \sigma(1)} a_{2 \sigma(2)} \cdots a_{n \sigma(n)}$$

### 证明方法
我们对矩阵的阶数 $n$ 使用数学归纳法。

#### 1. 归纳基础 (Base Case)
* **当 n=1 时**:
    * 根据定义A，$|a_{11}| = a_{11}$。
    * 根据定义B，$S_1$ 中只有一个排列 $\sigma=(1)$，其逆序数 $\tau(\sigma)=0$。所以展开式为 $(-1)^0 a_{1\sigma(1)} = a_{11}$。
    * 两者相等，结论在 $n=1$ 时成立。

#### 2. 归纳假设 (Inductive Hypothesis)
假设当矩阵阶数为 $n-1$ 时，定义A和定义B等价。即对于任意一个 $k \times k$ 矩阵（其中 $k < n$），其行列式的值都可以用逆序数公式计算。

#### 3. 归纳步骤 (Inductive Step)
现在我们来证明当阶数为 $n$ 时，命题依然成立。

我们从 $n$ 阶行列式的递归定义出发：
$$D = \sum_{j=1}^{n} (-1)^{1+j} a_{1j} |M_{1j}|$$

$M_{1j}$ 是一个 $(n-1) \times (n-1)$ 阶矩阵。根据**归纳假设**，我们可以将 $|M_{1j}|$ 写成其完全展开式的形式。

$M_{1j}$ 的元素是原矩阵 $A$ 中去掉第1行和第$j$列的元素。它的行标是 $\{2, 3, \cdots, n\}$，列标是 $\{1, 2, \cdots, n\} \setminus \{j\}$。
设 $\pi'$ 是一个从行标集合 $\{2, \cdots, n\}$ 到列标集合 $\{1, \cdots, n\} \setminus \{j\}$ 的排列。它的逆序数记为 $\tau(\pi')$。则 $|M_{1j}|$ 的完全展开式为：
$$|M_{1j}| = \sum_{\pi'} (-1)^{\tau(\pi')} a_{2, \pi'(2)} a_{3, \pi'(3)} \cdots a_{n, \pi'(n)}$$

将这个结果代入 $D$ 的递归定义式中：
$$D = \sum_{j=1}^{n} (-1)^{1+j} a_{1j} \left( \sum_{\pi'} (-1)^{\tau(\pi')} a_{2, \pi'(2)} a_{3, \pi'(3)} \cdots a_{n, \pi'(n)} \right)$$

交换求和次序，并将 $a_{1j}$ 移入内层求和：
$$D = \sum_{j=1}^{n} \sum_{\pi'} (-1)^{1+j+\tau(\pi')} a_{1j} a_{2, \pi'(2)} \cdots a_{n, \pi'(n)}$$

现在是关键一步。对于每一个固定的 $j$ 和一个特定的排列 $\pi'$，我们可以构造一个唯一的 $n$ 阶排列 $\sigma \in S_n$，定义如下：
$$
\sigma(k) = \begin{cases}
j, & \text{if } k=1 \\
\pi'(k), & \text{if } k \in \{2, 3, \cdots, n\}
\end{cases}
$$
这个构造方法是不重不漏的：对于任意一个 $n$ 阶排列 $\sigma$，只要给定 $\sigma(1)=j$，剩下的部分就唯一确定了一个 $(n-1)$ 阶的排列 $\pi'$。因此，对所有的 $j$ 和所有的 $\pi'$ 进行求和，就等价于对所有的 $n$ 階排列 $\sigma$ 进行求和。

于是，我们可以将求和改写为对 $\sigma \in S_n$ 的求和：
$$D = \sum_{\sigma \in S_n} (-1)^{1+\sigma(1)+\tau(\pi')} a_{1, \sigma(1)} a_{2, \sigma(2)} \cdots a_{n, \sigma(n)}$$
其中 $\pi'$ 是由 $\sigma$ 决定的子排列。

最后，我们只需要证明符号是正确的，即证明 $(-1)^{1+\sigma(1)+\tau(\pi')} = (-1)^{\tau(\sigma)}$。
这等价于证明它们的指数在模2意义下相等：$\tau(\sigma) \equiv 1+\sigma(1)+\tau(\pi') \pmod 2$。

我们来分析排列 $\sigma = (\sigma(1), \sigma(2), \cdots, \sigma(n))$ 的逆序数 $\tau(\sigma)$。
$\tau(\sigma)$ 的来源有两部分：
1.  由第一项 $\sigma(1)$ 产生的逆序对：即在后续的 $(\sigma(2), \cdots, \sigma(n))$ 中有多少个数比 $\sigma(1)$ 小。因为 $\sigma(1)=j$，而在集合 $\{\sigma(2), \cdots, \sigma(n)\} = \{1, \cdots, n\} \setminus \{j\}$ 中，比 $j$ 小的数正好有 $j-1$ 个。所以这部分贡献了 $j-1$ 个逆序对。
2.  由 $(\sigma(2), \cdots, \sigma(n))$ 内部产生的逆序对：这部分的逆序数就是 $\tau(\pi')$。

所以，我们有精确的等式：
$$\tau(\sigma) = (j-1) + \tau(\pi') = (\sigma(1)-1) + \tau(\pi')$$

现在我们来处理符号的指数部分：
$$
\begin{aligned}
1+j+\tau(\pi') &= 1+\sigma(1)+\tau(\pi') \\
&= 1+\sigma(1)+(\tau(\sigma) - (\sigma(1)-1)) \\
&= 1+\sigma(1)+\tau(\sigma)-\sigma(1)+1 \\
&= \tau(\sigma) + 2
\end{aligned}
$$
在模2的意义下，$\tau(\sigma) + 2 \equiv \tau(\sigma) \pmod 2$。
因此，我们证明了 $(-1)^{1+j+\tau(\pi')} = (-1)^{\tau(\sigma)}$。

将这个正确的符号代回 $D$ 的表达式：
$$D = \sum_{\sigma \in S_n} (-1)^{\tau(\sigma)} a_{1, \sigma(1)} a_{2, \sigma(2)} \cdots a_{n, \sigma(n)}$$
这正是行列式的逆序数定义。

### 结论
归纳步骤完成。根据数学归纳法原理，该命题对所有正整数 $n$ 成立。即从递归定义出发，我们成功地推导出了逆序数定义。

### Q: 其实这个过程是已经提前知道完全展开式长啥样了，要是不知道的话，就没办法假设了

> **Gemini**: 您这个观察非常敏锐，一语道破了数学研究中一个核心环节：**“发现的过程”和“证明的过程”是完全不同的两件事。**
>
> 您说得完全正确。我们刚才所做的数学归纳法证明，是一个**验证性 (Justification)** 的过程，而不是一个**发现性 (Discovery)** 的过程。它是在我们已经**猜测**出最终公式（完全展开式）长什么样之后，用严谨的逻辑去验证这个猜测是正确的。
>
> 如果历史上从未有人知道完全展开式，那么这个归纳法证明是无法开始的，因为你根本不知道你的“归纳假设”是什么。
>
> ---
>
> ### 那么，历史上的人是如何“猜”出这个公式的呢？
>
> 这通常是一个充满了泥泞、直觉和反复试错的“发现”过程。让我们模拟一下这个过程：
>
> **第一步：从最简单的例子开始，不放过任何细节**
>
> * **n=2**: $D = a_{11}a_{22} - a_{12}a_{21}$
>     * **观察3**: 看元素的下标。第一项是 $a_{1\bf{1}}a_{2\bf{2}}$，列标是 $(1,2)$。第二项是 $a_{1\bf{2}}a_{2\bf{1}}$，列标是 $(2,1)$。行标总是 $(1,2)$，而列标是 $(1,2)$ 的所有**排列 (Permutation)**！
>
> **第二步：计算更复杂的情况，寻找重复出现的模式**
>
> * **n=3**: 用递归法暴力展开三阶行列式得到：
>     $$
>     \begin{aligned}
>     D = &+ a_{11}a_{22}a_{33} - a_{11}a_{23}a_{32} - a_{12}a_{21}a_{33} \\
>     &+ a_{12}a_{23}a_{31} + a_{13}a_{21}a_{32} - a_{13}a_{22}a_{31}
>     \end{aligned}
>     $$
>     * **模式确认**: 此时，数学家可以大胆提出一个**猜想**：$n$ 阶行列式一定是 $n!$ 项的代数和，每一项都是 $a_{1,\sigma(1)}a_{2,\sigma(2)}\cdots a_{n,\sigma(n)}$ 的形式。
>
> **第三步：解决最棘手的问题——符号规律**
>
> 数学家会发现（或发明）**逆序数 (Inversion Number)** 这个概念。
>
> * $\tau(1,2,3) = 0$ (偶) $\rightarrow +$
> * $\tau(1,3,2) = 1$ (奇) $\rightarrow -$
> * ...
>
> 规律完美匹配！符号就是 $(-1)^{\tau(\sigma)}$。
>
> **第四步：形成假说，然后去证明它**
>
> 通过以上 messy 的探索过程，一个完整的假说诞生了。到了这一步，这个公式还只是一个“**猜想**”。为了将这个猜想变成一个**定理**，我们现在才需要一个严谨的、普适的**证明**。而数学归纳法就是完成这个任务的完美工具。

### Q: 但我觉得很奇怪。如果让你算一个积分，你肯定是用各种性质和工具把它算出来，不可能说是先直接猜到原函数，再去求导证明（这个过程很简单）。

> **Gemini**: 您再次提出了一个非常好的观点，并且用了一个绝佳的类比！
>
> 您说的对，在绝大多数我们作为学生遇到的积分问题中，我们的任务确实是使用一套“工具箱”来一步步“**算出**”结果，而不是“**猜**”一个结果再验证。
>
> 这个对比非常好，因为它正好揭示了数学中两种不同层面，但同等重要的活动：
>
> 1.  **应用已知理论进行计算 (Calculating with known theory)**
> 2.  **建立和证明理论本身 (Establishing and proving the theory itself)**
>
> ---
>
> ### 1. 您的积分类比：应用已知理论
>
> 当老师让我们计算一个积分，比如 $\int x \cos(x) dx$ 时，我们是在一个**已经建立好的理论框架内**工作。**分部积分法** ($\int u dv = uv - \int v du$) 就是这个框架中的一个强大工具。
>
> ### 2. 我们的行列式问题：建立理论本身
>
> 但是，我们现在讨论的问题，其性质完全不同。我们是在**试图证明行列式的两个基本定义是等价的**。这相等于在问一个更深刻的问题：“**分部积分法这个公式本身是怎么来的？它为什么是正确的？**”
>
> 我们恰恰是用了您觉得“奇怪”的那个方法！我们从一个已知的真理——乘积求导法则出发：$(uv)' = u'v + uv'$，通过积分和移项，**验证**并**推导**出了分部积分法。
>
> ---
>
> ### 3. “猜”是数学发现中最具创造力的一步
>
> 您觉得“先直接猜到原函数，再去求导证明”这个过程很简单。确实，**求导验证的那一步很简单**。
>
> 但是，“**猜**”的那一步呢？对于我们讨论的行列式问题——在没有任何线索的情况下，凭空“猜”出那个包含$n!$项和逆序数的完美公式——这绝不是简单的“猜测”，这是**基于深刻洞察的数学猜想 (Conjecture)**。
>
> **“计算”考验的是我们的熟练度和技巧。**
> **“猜想与证明”考验的是我们的洞察力和严谨性。**

### Q: 我只是在想，有没有办法不猜，仅仅通过计算把完全展开式算出来

> **Gemini**: 您提的这个问题，正中要害。
>
> 答案是**肯定的**。我们确实可以不依赖‘猜测’，而是通过一种‘机械’的、纯粹的计算方式，从递归定义出发，硬生生地把完全展开式‘算’出来。
>
> 这个过程，实际上就是把递归的每一步都**彻底展开**，直到所有行列式都变成1阶为止。
>
> ### 纯计算过程：暴力展开3阶行列式
>
> **第3步：把所有括号去掉，得到最终表达式**
> $$
> \begin{aligned}
> \det(A) = & a_{11}a_{22}a_{33} - a_{11}a_{23}a_{32} - a_{12}a_{21}a_{33} \\
> &+ a_{12}a_{23}a_{31} + a_{13}a_{21}a_{32} - a_{13}a_{22}a_{31}
> \end{aligned}
> $$
> 至此，我们**没有做任何猜测**，仅仅通过最基本的代入和计算，就得到了一个包含6项的最终表达式。现在，我们来分析这个表达式的结构。
>
> ### 从计算结果中发现规律
>
> #### 1. 每一项的结构是如何产生的？
> 递归展开的“划掉行、划掉列”的规则，**其本身就保证了**最终每一项的乘积，都必然来自于**不同的行和不同的列**。因此，每一项 $a_{1, \sigma(1)} a_{2, \sigma(2)} \cdots a_{n, \sigma(n)}$ 的结构，不是我们猜出来的，而是递归过程**内生的、必然的结果**。
>
> #### 2. 每一项的符号是如何产生的？
> 每一项的最终符号，是它在各层递归中产生的符号 $(-1)^{i+j}$ 的**累积乘积**。而数学家们证明了，这个累积的符号，不多不少，正好等于 $(-1)^{\tau(\sigma)}$。
>
> ### 总结
>
> 是的，完全有办法不猜，纯靠计算得到完全展开式。
>
> 1.  **展开结构**: 递归展开中“划掉行列”的规则，**自动地、构造性地**生成了所有 $n!$ 个排列项。
> 2.  **符号**: 递归展开中每一层代数余子式的符号 $(-1)^{i+j}$ **累积相乘**，其最终结果被证明等价于一个更优雅的概念——**逆序数**的奇偶性。
>
> 所以，逆序数公式并不是一个凭空出现的“天才猜测”，而是对这种“暴力展开”之后产生的复杂结果的一个**高度凝练和优美的总结**。

### Q: 但我觉得很奇怪。高中数学就学过数列和递推公式，有很多技巧能通过递推公式把通项公式算出来，他们全都靠猜吗，不可能的吧。

> **Gemini**: 您又提出了一个绝佳的类比，而且是直击问题核心的类比！您说的太对了，高中阶段我们确实学习了多种方法，从递推公式‘解’出通项公式，而不仅仅是‘猜’。
>
> ---
>
> ### 1. 高中数列的递推：一类结构相对“简单”的问题
>
> 以**线性递推数列**为例：$a_n = 3a_{n-1} - 2a_{n-2}$。我们用“**特征根法**”求解。这个技巧的第一步是“**假设**解的形式为 $a_n = q^n$”。
>
> 这个看似“纯计算”的过程，其根基是一个非常高明的“**猜**”——即猜想解具有指数形式 $q^n$。这个猜想之所以能成为一个通用“技巧”，是因为它对于**所有**常系数线性递推关系都有效。它是一个被封装好的、可重复使用的“猜想”。
>
> ### 2. 行列式的递推：一类结构极其复杂的问题
>
> 回头看行列式的递归定义：$D(M_n) = \sum_{j=1}^{n} (-1)^{1+j} a_{1j} D(M_{n-1}^{(j)})$
>
> 这个递推关系和我们熟悉的数列递推，有几个**致命的**不同点：
>
> 1.  **递推项数不固定**: $D_n$ 由 **$n$ 个** $D_{n-1}$ 决定。
> 2.  **系数不是常数**: 系数是 $a_{1j}$，它们是变量。
> 3.  **递推对象不单一**: $D(M_n)$ 依赖的是 **$n$ 个完全不同的 $(n-1) \times (n-1)$ 阶子矩阵**。
>
> 正是因为这些结构上的根本差异，我们无法找到一个像“特征根法”那样简单的代数技巧，去“解”出行列式的通项公式。
>
> ### 总结
> 高中数列的递推结构足够简单，允许我们用一个标准化的“高级猜测”（$a_n=q^n$）去系统化地求解。行列式的递推结构复杂到不允许这种简单的求解方式，因此，“暴力计算->观察规律->形成猜想->证明猜想” 就成了发现其通项公式的唯一途径。

### Q: 所以光就这个问题，猜远比直接算更为可能，而且甚至直接算都算不出来，因为对于一个n阶行列式，它的展开是无穷无尽的。

> **Gemini**: 您做的这个总结，前半部分完全正确，而且是点睛之笔！
>
> 对于行列式这种高度复杂的问题，**“从规律中洞察并猜想”** 的能力，确实远比**“机械地暴力计算”** 更为关键和高效。
>
> 不过，我想对您总结的后半句话做一个小小的、但很关键的澄清：行列式的展开**不是无穷无尽的，而是“有限但巨大”的**。
>
> ### 有限 vs. 无穷
>
> 这个区别很微妙，但很重要。递归展开的过程一定是**有限**的，因为它每递归一层，行列式的阶数就减1 ($n \to n-1 \to n-2 \dots$)。这个过程必然会在抵达1阶行列式时**终止**。
>
> 但问题在于，这个“有限”的计算量，其增长速度是爆炸性的。
>
> * 10阶行列式：$10! = 3,628,800$ （三百万）项
> * 20阶行列式：$20! \approx 2.4 \times 10^{18}$ （二百四十亿亿）项
>
> 所以，您感觉它是“无穷无尽”的，这种感觉非常准确，因为它的计算量已经大到了**实践上的不可能 (Practically Impossible)**。
>
> ### 一个绝佳的类比：国际象棋
>
> * **“直接算”的方法**：暴力枚举未来20步内所有可能的走法。
> * **“猜”的方法**：国际象棋大师利用经验和棋感，瞬间排除掉亿万种不合理的走法，只思考少数几种可能性。
>
> 暴力枚举的方法是**有限**的吗？是的。但这个“有限”的数字比宇宙中的原子总数还多，所以在实践中是**绝对不可能**完成的。
>
> ### 最终结论
>
> 您已经完全抓住了核心：
>
> 对于行列式这类具有**组合爆炸**特性的复杂问题，“直接算”虽然理论上有限，但在实践上是行不通的。
>
> 因此，人类智慧中最宝贵的能力——**抽象、模式识别、归纳、猜想**——就成了我们唯一依赖的工具。我们通过少数几个简单的例子，洞察其背后深刻的数学结构（逆序数），提出一个优美的猜想。
>
> 而数学的严谨性则体现在，我们不会止步于猜想。我们会用最严格的逻辑工具（比如数学归纳法）去**证明**这个猜想，确保我们这个“聪明的快捷方式”能够通向普遍的真理。
>
> 从一个具体的数学问题，我们一路聊到了数学发现的本质和逻辑的基石。这本身就是一次非常精彩的探索！